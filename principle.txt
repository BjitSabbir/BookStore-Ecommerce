//Customar Type 
#silver user 0-100 transection will get 0% discount
#gold user 100-200 transection will get 2% discount
#platinum user 200-300 transection will get 4% discount
#diamond user 300-> transection will get 6% discount

//discount 
# add discount based on time 
# if one product has multiple discount, latest discount will be applied 
# if a  product has multiple discount and latest discount is disabled/ deleted the previous discount will be applied 
# if a discount removed or deleted then the discount will be removed
# if a discount is update then the discount will be removed by scheduler and will be again applied after one minute

    async addToCart(req, res) {
        const { bookId, quantity } = req.body;

        try {
            const book = await BookModel.findById(bookId);

            if (!book) {
                return res
                    .status(NOT_FOUND)
                    .send(errorMessage("Book not found"));
            }

            if (quantity < 1) {
                return res
                    .status(BAD_REQUEST)
                    .send(errorMessage("Quantity must be greater than 0"));
            }

            if (book.stock_quantity < quantity) {
                return res
                    .status(BAD_REQUEST)
                    .send(errorMessage("Quantity not available"));
            }

            const price = book.isDiscountActive
                ? book.price * (1 - book.discount_percentage / 100)
                : book.price;

            const cart = await CartModel.findOne({ userId: req.user.userId });

            if (!cart) {
                const newCart = new CartModel({
                    userId: req.user.userId,
                    books: [{ bookId, price, quantity }],
                    total: price * quantity,
                });
                await newCart.save();
                return res
                    .status(CREATED)
                    .send(
                        successMessage(
                            "Book added to cart successfully",
                            newCart
                        )
                    );
            }

            const existingBookIndex = cart.books.findIndex(
                (cartItem) => cartItem.bookId.toString() === bookId
            );

            if (existingBookIndex !== -1) {
                if (
                    cart.books[existingBookIndex].quantity + quantity >
                    book.stock_quantity
                ) {
                    return res
                        .status(BAD_REQUEST)
                        .send(errorMessage("Quantity not available"));
                }
                cart.books[existingBookIndex].quantity += quantity;
            } else {
                cart.books.push({ bookId, price, quantity });
            }

            cart.total = cart.books.reduce(
                (total, book) => total + book.price * book.quantity,
                0
            );
            await cart.save();
            return res
                .status(OK)
                .send(successMessage("Cart item updated successfully", cart));
        } catch (err) {
            console.error(err);
            return res
                .status(BAD_REQUEST)
                .send(errorMessage("Failed to add book to cart"));
        }
    }